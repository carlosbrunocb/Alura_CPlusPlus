@ [Makefile]
  * É um arquivo com configurações de build (compilação) dos arquivos c++

  + Comentário: Para inserir comentários em um arquivo makefile basta usar o #.
    Ex.: 
         # Isso é um comentário e não será aplicado/lido quando o arquivo Makefile
         # for executado.


@ [VS-CODE] Dicas e comandos de edição de texto
  * SEGURE o ctrl + alt [nessa ordem] e arraste para baixo até a linha desejada: 
    Isso permite que várias linhas sejam editadas ao mesmo tempo
    Ex:
        chutou ['A'] = falso  ==>>      chutou ['A'] = falso  
        |                               chutou ['M'] = verdadeiro
        |                               chutou ['O'] = falso
        |                               chutou ['R'] = falso
                                
@ [fstream] ifstream: leitura de arquivos
  * '>>': consegue ser usado para ler uma linha do arquivo
    Ex.: dados_do_arquivo >> variavel;

@ [Compilação C++] Comandos de compilação
  * Compilação de arquivos para geração da unidade de tradução (código binário) -
    conhecido como código intermediário ou objeto.
    [arquivo objeto: file.o]
    Ex.: 
      $ g++ -c file.cpp
      >> resultado: file.o
  * Compilação de arquivos para geração de um arquivo executável [linking]
    [file.exe]
    Ex.:
      $ g++ -o *.cpp file.exe
  
  OBS.:
    + Podemos gerar várias unidade de tradução (arquivos objetos). Isso permite, isolar a compilação
      à arquivos individuais facilitando a manuntanção do software, pois, se precisar alterar uma parte
      do código só precisamos compilar o aquivo em que ele se encontra e depois gerar o executavel pelo
      processo de ligação das unidade de tradução.
       
@ [C++] NOTAS
  # extern: é um comando usado em variáveis globais, funções ou declaração de template
      para especificar que há uma LIGAÇÃO EXTERNA ("external linkage"), ou seja, evitar 
      duplicidade de declaração e informar ao compilador que aquela declaração já existe em
      algum arquivo ou parte da codificação e que novas declarações do mesmo identificador e 
      tipo devem usar essa declaração extern. Logo, é criado uma LIGAÇÃO de declaração para todas
      as suas duplicadas informando para usar apenas uma. 
      UM -->> TODOS
      O comando 'extern' tem quatro significado dependendo do contexto:
        + Declaração de variáveis global não constante (non-const), extern especifica que variável
          ou função é definida em outra unidade de tradução. O extern deve ser aplicado em todos os
          arquivos exceto naquele onde a variável foi definida.
        + Declaração de variáveis constantes (const), ele especifica que variável tem uma ligação 
          externa. O extern deve ser aplicado a todas a declarações em todos os arquivos.
        + extern "C" especifica que a função é definida em outro lugar e usa a chamada convencional 
          da linguagem C. O extern "C" é um modificador que pode ser aplicado a múltiplas declarações
          de funções em um bloco.
        + Declaração de template, extern especifica que o template foi instanciado em outro lugar. 
          extern informa ao compilador que ele pode reusar a outra instanciação, em vez de criar uma
          nova no local atual.
        Ex.:
          - extern ligação para constantes não globais (non-const globals)
              //fileA.cpp
              int i = 42; // declaration and definition

              //fileB.cpp
              extern int i;  // declaration only. same as i in FileA

              //fileC.cpp
              extern int i;  // declaration only. same as i in FileA

              //fileD.cpp
              int i = 43; // LNK2005! 'i' already has a definition.
              extern int i = 43; // same error (extern is ignored on definitions)

          - extern ligação para constantes globais (const global)
              //fileA.cpp
              extern const int i = 42; // extern const definition

              //fileB.cpp
              extern const int i;  // declaration only. same as i in FileA
          
          - extern constexpr
              extern constexpr int x = 10; //error LNK2005: "int const x" already defined
              extern constexpr __declspec(selectany) int x = 10;
          
          - extern "C" e extern "C++" para declarações de funções
              // Declare printf with C linkage.
              extern "C" int printf(const char *fmt, ...);

              //  Cause everything in the specified
              //  header files to have C linkage.
              extern "C" {
                  // add your #include statements here
              #include <stdio.h>
              }

              //  Declare the two functions ShowChar
              //  and GetChar with C linkage.
              extern "C" {
                  char ShowChar(char ch);
                  char GetChar(void);
              }

              //  Define the two functions
              //  ShowChar and GetChar with C linkage.
              extern "C" char ShowChar(char ch) {
                  putchar(ch);
                  return ch;
              }

              extern "C" char GetChar(void) {
                  char ch;
                  ch = getchar();
                  return ch;
              }

              // Declare a global variable, errno, with C linkage.
              extern "C" int errno;
              ---------------------
              extern "C" int CFunc1();
              ...
              int CFunc1();           // Redeclaration is benign; C linkage is
                                      //  retained.

              int CFunc2();
              ...
              extern "C" int CFunc2(); // Error: not the first declaration of
                                       //  CFunc2;  cannot contain linkage
                                       //  specifier.

  #pragma once: Instrução de pré-processamento que informa que arquivo de cabeçalho será
    incluído apenas uma vez pelo compilador.
    * É uma diretiva de compilação não padrão (not standard), geralmente, utilizada para 
      otimização de múltiplas includes (multiple-include optimization).
      + Ela é usadar em headers para fazer com que o ficheiro atual apenas seja incluído 
        uma vez durante o processo de compilação.
    Ex.:
      File "creature.h"

      #pragma once

      struct creatureInfo
      {
          int member;
      };
      -----------------
      File "animal.h"

      #include "creature.h"
      -----------------
      File "human.h"

      #include "creature.h"
      #include "animal.h"

  # inline functions: informa ao compilador para substituir o código na definição função
      para cada instância da chamada da função.
      * Pode permitir que seu programa seja mais rápido porque ele elimina a sobrecarga 
        associada às chamadas de função.
      * A substituição do código embutido ocorre a critério do compilador. Por exemplo, o 
        compilador não vai embutir uma função se seu endereço já estiver em uso ou se for 
        muito grande para embutir.
      * Esses tipos devem ser declarados no cabeçalho porque ela serão trazidas para dentro
        da função, ou seja, ele irá ficar na mesma unidade de tradução.
        OBS.:
          + Arquivos cabeçalho não são compliados. Eles são importados para dentro do código que os
            inclue. (Mesmo conceito das funções embutidas - inline fucntios) 
          + Para o compilador decidir isso ele precisa conhecer a função.
      * Uma função definida no corpo de uma declaração de classe é, implicitamente, uma 
        função embutida.
      * Uma função inline não é compilada por si só. Se você modificar uma função inline, 
        todos os arquivos que a usam vão precisar ser recompilados.

      Ex.:
        // Inline_Member_Functions.cpp
        class Account
        {
        public:
            Account(double initial_balance) { balance = initial_balance; }
            double GetBalance();
            double Deposit( double Amount );
            double Withdraw( double Amount );
        private:
            double balance;
        };

        inline double Account::GetBalance()
        {
            return balance;
        }

        inline double Account::Deposit( double Amount )
        {
            return ( balance += Amount );
        }

        inline double Account::Withdraw( double Amount )
        {
            return ( balance -= Amount );
        }
        int main()
        {
        }
  # Desreferenciação de ponteiro: 
    Ex.:
      map<string, int>* variable;
      vector<string>* variable0;

      (*variable)[str] = 1;
      variable0->push_back(str);
      (*variable0).push_back(str);

  # Referencia em c++: Em c++ pode-se passar referências de maneiras "simplificada"
      dentro da função que o compilador vai entender que está passando um endereço
      não precisando desreferenciar depois.
      Ex.:
        function(char& var, int& var1);

        //In the function call
        function(var, var1);
  # const em referências: Usado para indicar que um parâmetro passado como referência
      não será modificado o seu valor na função.
      Ex.:
        // const char& var indica que valor passado como referência não pode se modificado
        function(const char& var, int& var1);
  # static: Pode ser usado para definir uma variável global ou símbolo como existente apenas
      na translate unit em que ela foi declarada. Logo, elas estarão acessiveis apenas dentro
      da translate unit em forem declaradas.
  # namespace: É uma declaritva regional que fornece um escopo para os identificadores (funções, 
      nomes de tipos, variáveis, etc) inseridos nele. Eles são usados para organizar o código 
      dentro de grupos locais e para previnir colisões de nomes que podem ocorrer quando o código
      é baseado na inclusão de múltiplas bibliotecas.
      Operardor de resolução de nomes :: 
      Ex.:
        namespace ContosoData
        {
            class ObjectManager
            {
            public:
                void DoSomething() {}
            };
            void Func(ObjectManager) {}
        }

        ContosoData::ObjectManager mgr;
        mgr.DoSomething();
        ContosoData::Func(mgr);
  # stack: bloco de memória que é alocado para um função, procedimento ou método em C++.
      Ela contém a pilha de execução, onde são armezanadas os parâmetros, endereços de retorno
      e variáveis locais de funções. Elas são estática e pré-alocada no inicio do programa e 
      desalocada no final.
      
      